<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
    <title>What is Nearby?</title>
    <script type="text/javascript" src="lib/require.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
    <link rel="stylesheet" type="text/css" href="css/flat-index.css" />
</head>

<body>

<div id="header">
  <font color=#ffd9be>S</font><font color=#8fe9da>c</font><font color=#ffe07e>a</font><font color=#ffcfcf>r</font><font color=#b795c7>l</font><font color=#ffd9be>e</font><font color=#8fe9da>t</font><font color=#ffe07e>t</font>
</div>

<div id="inputs" align="center">
  <form>
    <div class = "container">
      <input type="text" onkeyup="showResult(this.value.toLowerCase())" onfocusout="clearSuggestions()">
      <button id="parse" class="button" type="button">&#9655;</button><!-- filled in: &#9654; outline: &#9655;-->
    </div>

    <div style="width: 80%; display: table;">
    <div style="display: table-row">
        <div style="display: table-cell;"><div id="autocomplete" class="suggestions"></div></div>
        <div style="display: table-cell;width:60px;"></div>
    </div>
    </div>
  </form>
<!--
  <div class="container">
     <div id="autocomplete" class="suggestions"></div>
     <div style="width:60px;"></div>
  </div>-->
</div>
<div align="center" style="margin-top:10px;">
   <div id="tokens" style="width:80%;text-align:left;"><br></div>
   <div id="treediv" style="width:80%;text-align:left;"></div>
</div>

<script type="text/javascript">
//Thanks to http://tomassetti.me/antlr-and-the-web/
var updateTree = function(tree, ruleNames) {
    var container = document.getElementById("treediv");
    while (container.hasChildNodes()) {
        container.removeChild(container.lastChild);
    }
    recurseTree(container, tree, ruleNames)
};

var recurseTree = function(container, tree, ruleNames) {
    if (tree.children !== undefined && tree.children != null) {
        for (var i = 0; i < tree.children.length; i++) {
            var child = tree.children[i];
            recurseTree(container, child, ruleNames);
        }
        var nodeType = ruleNames[tree.ruleIndex];
        var newElement = document.createElement("div");
        newElement.className = "NearbyApplication";
        var newElementText = document.createTextNode(nodeType);//child.children[2].getText());
        newElement.appendChild(newElementText);
        container.appendChild(newElement);
    }
};

var ErrorListener = require('antlr4/error/ErrorListener').ErrorListener;
function TestGrammarErrorListener() {
    ErrorListener.call(this);
    this.partialApplication = null;
    this.errors = [];    
    return this;
}


TestGrammarErrorListener.prototype = Object.create(ErrorListener.prototype);
TestGrammarErrorListener.prototype.constructor = TestGrammarErrorListener;

var testTokens; //TEST global for console stuff
var testParser;
TestGrammarErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
    this.errors.push(arguments);
    console.log("PARSER ERROR");
    console.log(msg);
    var parser = recognizer._ctx.parser; 
    testParser = recognizer._ctx.parser; 
    testTokens = parser.getExpectedTokens(); //CRITICAL. This is an interval set with the numbers that correspond to the expected token types
    tokenString = testTokens.toString();
    tokenArray = tokenString.substring(1,tokenString.length-1).split(", ");
    for (i in tokenArray) {
        tokenArray[i] = parser.symbolicNames[parseInt(tokenArray[i], 10)];
    }
    console.log(tokenArray);

    this.partialApplication = null;
    var typeAssistTokens = parser.symbolicNames;
    var tokens = parser.getTokenStream().tokens;

    //var tokenString = "";
    //for (i in tokens) {
    //    tokenString += parser.symbolicNames[tokens[i].type] + " ";
    //}
    //document.getElementById("tokens").innerHTML=tokenString;

    // last token is always "fake" EOF token
    if (tokens.length > 1) {
        var lastToken = tokens[tokens.length - 2],
            tokenType = parser.symbolicNames[lastToken.type];

        this.tokenType = tokenType;
        if (typeAssistTokens.indexOf(tokenType) >= 0) {
            this.partialApplication = lastToken.text;
            console.log("partial application: " + this.partialApplication);
        }
   }

//    if (str.length==0) { 
//        document.getElementById("autocomplete").innerHTML="";
//        document.getElementById("autocomplete").style.border="0px";
//        return;
//    } else {
        if (window.XMLHttpRequest) {
            // code for IE7+, Firefox, Chrome, Opera, Safari
            xmlhttp=new XMLHttpRequest();
        } else {  // code for IE6, IE5
            xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
        }
        xmlhttp.onreadystatechange=function() {
            if (xmlhttp.readyState==4 && xmlhttp.status==200) {
              document.getElementById("autocomplete").innerHTML=xmlhttp.responseText;
              document.getElementById("autocomplete").style.border="1px solid #A5ACB2";
            }
        }
        var qString = "lib/autocomplete.php?";
        for (i in tokenArray) {
            qString += "q[]=_" + tokenArray[i] + "&";
        }
        var text = "";
        for (i in tokens) {
            if (i < tokens.length - 1) {
                text += tokens[i].text + " ";
            }
        }
        qString += "text=" + text;
        console.log(qString);
        xmlhttp.open("GET",qString,true);
        xmlhttp.send();
 //   }
};


function clearSuggestions() {
    console.log("made it");
    document.getElementById("autocomplete").innerHTML="";
    document.getElementById("autocomplete").style.border="0px solid #A5ACB2";
}

var antlr4 = require('antlr4/index');
var NearbyLexer = require('generated-parser/NearbyLexer');
var NearbyParser = require('generated-parser/NearbyParser');


document.getElementById("parse").addEventListener("click", function(){
    //var input = document.getElementById("autocomplete").value;
    //var chars = new antlr4.InputStream(input);
    //var lexer = new NearbyLexer.NearbyLexer(chars);
    //var tokens  = new antlr4.CommonTokenStream(lexer);
    //var parser = new NearbyParser.NearbyParser(tokens);
    //var listener = new TestGrammarErrorListener();
    //parser.removeErrorListeners();
    //parser.addErrorListener(listener);
    //parser.buildParseTrees = true;
    //var tree = parser.application();
    //updateTree(tree, parser.ruleNames);
    var target_sentence = {
  'type': 'immediate action',
  'action': {
    'verb': 'turn on',
    'object': {
      'determiner': 'the',
      'noun': 'lights'
    }
  }
};
    console.log(target_sentence);
    var str_json = JSON.stringify(target_sentence);
    var request = new XMLHttpRequest();
    request.open("POST", "lib/post-to-target.php", true);
    request.setRequestHeader("Content-type", "application/json");
    request.send(str_json); 
});

//var BailErrorStrategy = require('antlr4/error/ErrorStrategy').BailErrorStrategy;

function showResult(str) {
    var input = str;
    var chars = new antlr4.InputStream(input);
    var lexer = new NearbyLexer.NearbyLexer(chars);
    var tokens  = new antlr4.CommonTokenStream(lexer);
    var parser = new NearbyParser.NearbyParser(tokens);
    var listener = new TestGrammarErrorListener();
    parser.removeErrorListeners();
    parser.addErrorListener(listener);
    parser.buildParseTrees = true;
    //parser._errHandler = new BailErrorStrategy();
    console.log(parser._errHandler); //TEST
    var tree = parser.application();
    updateTree(tree, parser.ruleNames);
              
   document.getElementById("autocomplete").innerHTML="";
   document.getElementById("autocomplete").style.border="0px";
    
    var tokens = parser.getTokenStream().tokens;
    tokens = tokens.slice(0,tokens.length-1);

    var tokenString = "";
    for (i in tokens) {
        tokenString += parser.symbolicNames[tokens[i].type] + " ";
    }
    document.getElementById("tokens").innerHTML=tokenString;
}

</script>
</body>
</html>
