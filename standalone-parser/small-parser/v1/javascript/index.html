<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>Parsing with ANTLR</title>
    <script type="text/javascript" src="lib/require.js"></script>
</head>
<body>
<div id="inputs">
<!-- <textarea id="code" rows = "1" cols="50">
turn on the lights
</textarea> -->
<form>
<input type="text" size="80" onkeyup="showResult(this.value.toLowerCase())">
<div id="autocomplete"></div>
</form>
<br>
<button id="parse">Parse</button>
</div>
<div id="tokens">
<br>
</div>
<div id="treediv">
</div>

<script type="text/javascript">
//Thanks to http://tomassetti.me/antlr-and-the-web/
var updateTree = function(tree, ruleNames) {
    var container = document.getElementById("treediv");
    while (container.hasChildNodes()) {
        container.removeChild(container.lastChild);
    }
    recurseTree(container, tree, ruleNames)
};

var recurseTree = function(container, tree, ruleNames) {
    if (tree.children !== undefined && tree.children != null) {
        for (var i = 0; i < tree.children.length; i++) {
            var child = tree.children[i];
            recurseTree(container, child, ruleNames);
        }
        var nodeType = ruleNames[tree.ruleIndex];
        var newElement = document.createElement("div");
        newElement.className = "NearbyApplication";
        var newElementText = document.createTextNode(nodeType);//child.children[2].getText());
        newElement.appendChild(newElementText);
        container.appendChild(newElement);
    }
};

var ErrorListener = require('antlr4/error/ErrorListener').ErrorListener;
function TestGrammarErrorListener() {
    ErrorListener.call(this);
    this.partialApplication = null;
    this.errors = [];    
    return this;
}

TestGrammarErrorListener.prototype = Object.create(ErrorListener.prototype);
TestGrammarErrorListener.prototype.constructor = TestGrammarErrorListener;

var testTokens; //TEST global for console stuff
var testParser;
TestGrammarErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {
    this.errors.push(arguments);
    console.log("PARSER ERROR");
    console.log(msg);
    var parser = recognizer._ctx.parser; 
    testParser = recognizer._ctx.parser; 
    testTokens = parser.getExpectedTokens(); //CRITICAL. This is an interval set with the numbers that correspond to the expected token types
    tokenString = testTokens.toString();
    tokenArray = tokenString.substring(1,tokenString.length-1).split(", ");
    for (i in tokenArray) {
        tokenArray[i] = parser.symbolicNames[parseInt(tokenArray[i], 10)];
    }
    console.log(tokenArray);

    this.partialApplication = null;
    var typeAssistTokens = parser.symbolicNames;
    var tokens = parser.getTokenStream().tokens;

    //var tokenString = "";
    //for (i in tokens) {
    //    tokenString += parser.symbolicNames[tokens[i].type] + " ";
    //}
    //document.getElementById("tokens").innerHTML=tokenString;

    // last token is always "fake" EOF token
    if (tokens.length > 1) {
        var lastToken = tokens[tokens.length - 2],
            tokenType = parser.symbolicNames[lastToken.type];

        this.tokenType = tokenType;
        if (typeAssistTokens.indexOf(tokenType) >= 0) {
            this.partialApplication = lastToken.text;
            console.log("partial application: " + this.partialApplication);
        }
    }

//    if (str.length==0) { 
//        document.getElementById("autocomplete").innerHTML="";
//        document.getElementById("autocomplete").style.border="0px";
//        return;
//    } else {
        if (window.XMLHttpRequest) {
            // code for IE7+, Firefox, Chrome, Opera, Safari
            xmlhttp=new XMLHttpRequest();
        } else {  // code for IE6, IE5
            xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
        }
        xmlhttp.onreadystatechange=function() {
            if (xmlhttp.readyState==4 && xmlhttp.status==200) {
              document.getElementById("autocomplete").innerHTML=xmlhttp.responseText;
              document.getElementById("autocomplete").style.border="1px solid #A5ACB2";
            }
        }
        var qString = "lib/autocomplete.php?";
        for (i in tokenArray) {
            qString += "q[]=_" + tokenArray[i] + "&";
        }
        var text = "";
        for (i in tokens) {
            if (i < tokens.length - 1) {
                text += tokens[i].text + " ";
            }
        }
        qString += "text=" + text;
        console.log(qString);
        xmlhttp.open("GET",qString,true);
        xmlhttp.send();
 //   }
};


var antlr4 = require('antlr4/index');
var NearbyLexer = require('generated-parser/NearbyLexer');
var NearbyParser = require('generated-parser/NearbyParser');


document.getElementById("parse").addEventListener("click", function(){
    var input = document.getElementById("autocomplete").value;
    var chars = new antlr4.InputStream(input);
    var lexer = new NearbyLexer.NearbyLexer(chars);
    var tokens  = new antlr4.CommonTokenStream(lexer);
    var parser = new NearbyParser.NearbyParser(tokens);
    var listener = new TestGrammarErrorListener();
    parser.removeErrorListeners();
    parser.addErrorListener(listener);
    parser.buildParseTrees = true;
    var tree = parser.application();
    updateTree(tree, parser.ruleNames);
});

var BailErrorStrategy = require('antlr4/error/ErrorStrategy').BailErrorStrategy;

function showResult(str) {
    var input = str;
    var chars = new antlr4.InputStream(input);
    var lexer = new NearbyLexer.NearbyLexer(chars);
    var tokens  = new antlr4.CommonTokenStream(lexer);
    var parser = new NearbyParser.NearbyParser(tokens);
    var listener = new TestGrammarErrorListener();
    parser.removeErrorListeners();
    parser.addErrorListener(listener);
    parser.buildParseTrees = true;
    //parser._errHandler = new BailErrorStrategy();
    console.log(parser._errHandler); //TEST
    var tree = parser.application();
    updateTree(tree, parser.ruleNames);
              
   document.getElementById("autocomplete").innerHTML="";
   document.getElementById("autocomplete").style.border="0px";
    
    var tokens = parser.getTokenStream().tokens;
    tokens = tokens.slice(0,tokens.length-1);

    var tokenString = "";
    for (i in tokens) {
        tokenString += parser.symbolicNames[tokens[i].type] + " ";
    }
    document.getElementById("tokens").innerHTML=tokenString;
}

</script>
</body>
</html>
